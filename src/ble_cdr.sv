/*
	This file is generated by ble_cdr_gen.py script written by Brandon Hippe
	Arguments:
	+----------------+------------+
	|    Argument    |   Value    |
	+----------------+------------+
	|   adc_width    |     4      |
	|      fsym      |  1000000   |
	|  mf_clock_rec  |    True    |
	| ble_cdr_output | ble_cdr.sv |
	|    clk_freq    |  16000000  |
	+----------------+------------+
*/


// `define MATCHED_FILTER_CLOCK_RECOVERY 1
(* keep_hierarchy = "yes" *)
module ble_cdr #(
    parameter SAMPLE_RATE = 16,
    parameter DATA_WIDTH = 4,
    parameter MAX_PACKET_LEN = 376,
    parameter PREAMBLE_LEN = 8
) (
    input logic clk,
    input logic en, 
    input logic resetn,

    input logic [DATA_WIDTH-1:0] i_bpf, q_bpf,

    output logic demod_symbol, demod_symbol_clk,

    input logic [5:0] channel,
    output logic packet_detected
);

    localparam MF_PIPELINE = 5;
    localparam CDR_PIPELINE = 9;
    localparam DELAY_NEEDED = CDR_PIPELINE - MF_PIPELINE;

    // Delay line for demod_bit
    logic [DELAY_NEEDED-1:0] demod_bit_delay;

    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            demod_bit_delay <= 0;
        end else if (en) begin
            demod_bit_delay <= {demod_bit_delay[DELAY_NEEDED-2:0], demod_bit};
        end
    end

    // Use delayed bit
    logic demod_bit_aligned;
    assign demod_bit_aligned = demod_bit_delay[DELAY_NEEDED-1];

    always_comb begin
    demod_symbol = demod_bit_aligned;
    demod_symbol_clk = symbol_clk;
    end

    // Matched filter stuff
    logic demod_bit;

    matched_filter #(
        .SAMPLE_RATE(SAMPLE_RATE),
        .DATA_WIDTH(DATA_WIDTH)
    ) mf (
        .clk(clk),
        .resetn(resetn),
        .en(en),

        .i_data(i_bpf),
        .q_data(q_bpf),

        .demodulated_bit(demod_bit)
    );

    logic symbol_clk;
// `ifndef MATCHED_FILTER_CLOCK_RECOVERY

    // Preamble Detection stuff
    logic preamble_detected;
    preamble_detect #(
        .SAMPLE_RATE(SAMPLE_RATE)
    ) pd (
        .clk(clk),
        .resetn(resetn),
        .en(en),

        .data_bit(demod_bit),
        .preamble_detected(preamble_detected)
    );

    // Clock recovery stuff
    clock_recovery #(
        .SAMPLE_RATE(SAMPLE_RATE),
        .DATA_WIDTH(DATA_WIDTH)
    ) cr (
        .clk(clk),
        .resetn(resetn),
        .en(en),

        .i_data(i_bpf),
        .q_data(q_bpf),
        .preamble_detected(preamble_detected),

        .symbol_clk(symbol_clk)
    );

// `else

//     clock_recovery #(
//         .SAMPLE_RATE(SAMPLE_RATE)
//     ) cr (
//         .clk(~clk),
//         .en(en),
//         .resetn(resetn),

//         .mf_bit(demod_bit),

//         .symbol_clk(symbol_clk)
//     );

// `endif


    // Packet sniffer stuff
    logic [31:0] latched_acc_addr;
    logic [5:0] latched_channel;
    logic packet_detected_reg;

    assign latched_acc_addr = 32'h6b7d9171;
    assign latched_channel = 6'd37;

    // Keep the Flip-Flop ONLY for the signal that actually changes
    always_ff @(posedge clk or negedge resetn) begin
        if (~resetn) begin
            packet_detected <= 0;
        end else begin
            packet_detected <= packet_detected_reg;
        end
    end
    packet_sniffer #(
        .PACKET_LEN_MAX(MAX_PACKET_LEN),
        .PREAMBLE_LEN(PREAMBLE_LEN)
    ) ps (
        .symbol_clk(symbol_clk),
        .resetn(resetn),
        .en(en),

        .symbol_in(demod_bit_aligned),

        .packet_detected(packet_detected_reg),

        .acc_addr(latched_acc_addr),
        .channel(latched_channel)
    );

endmodule

